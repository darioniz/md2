{"version":3,"file":"scroll-dispatcher.js","sourceRoot":"","sources":["../../../../../src/lib/core/overlay/scroll/scroll-dispatcher.ts"],"names":[],"mappings":"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","sourcesContent":["import {ElementRef, Injectable, NgZone, Optional, SkipSelf} from '@angular/core';\r\nimport {Platform} from '../../platform/index';\r\nimport {Scrollable} from './scrollable';\r\nimport {Subject} from 'rxjs/Subject';\r\nimport {Observable} from 'rxjs/Observable';\r\nimport {Subscription} from 'rxjs/Subscription';\r\nimport 'rxjs/add/observable/fromEvent';\r\nimport 'rxjs/add/observable/merge';\r\nimport 'rxjs/add/operator/auditTime';\r\n\r\n\r\n/** Time in ms to throttle the scrolling events by default. */\r\nexport const DEFAULT_SCROLL_TIME = 20;\r\n\r\n/**\r\n * Service contained all registered Scrollable references and emits an event when any one of the\r\n * Scrollable references emit a scrolled event.\r\n */\r\n@Injectable()\r\nexport class ScrollDispatcher {\r\n  constructor(private _ngZone: NgZone, private _platform: Platform) { }\r\n\r\n  /** Subject for notifying that a registered scrollable reference element has been scrolled. */\r\n  _scrolled: Subject<void> = new Subject<void>();\r\n\r\n  /** Keeps track of the global `scroll` and `resize` subscriptions. */\r\n  _globalSubscription: Subscription = null;\r\n\r\n  /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */\r\n  private _scrolledCount = 0;\r\n\r\n  /**\r\n   * Map of all the scrollable references that are registered with the service and their\r\n   * scroll event subscriptions.\r\n   */\r\n  scrollableReferences: Map<Scrollable, Subscription> = new Map();\r\n\r\n  /**\r\n   * Registers a Scrollable with the service and listens for its scrolled events. When the\r\n   * scrollable is scrolled, the service emits the event in its scrolled observable.\r\n   * @param scrollable Scrollable instance to be registered.\r\n   */\r\n  register(scrollable: Scrollable): void {\r\n    const scrollSubscription = scrollable.elementScrolled().subscribe(() => this._notify());\r\n\r\n    this.scrollableReferences.set(scrollable, scrollSubscription);\r\n  }\r\n\r\n  /**\r\n   * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\r\n   * @param scrollable Scrollable instance to be deregistered.\r\n   */\r\n  deregister(scrollable: Scrollable): void {\r\n    if (this.scrollableReferences.has(scrollable)) {\r\n      this.scrollableReferences.get(scrollable).unsubscribe();\r\n      this.scrollableReferences.delete(scrollable);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Subscribes to an observable that emits an event whenever any of the registered Scrollable\r\n   * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\r\n   * to override the default \"throttle\" time.\r\n   */\r\n  scrolled(auditTimeInMs: number = DEFAULT_SCROLL_TIME, callback: () => any): Subscription {\r\n    // Scroll events can only happen on the browser, so do nothing if we're not on the browser.\r\n    if (!this._platform.isBrowser) {\r\n      return Subscription.EMPTY;\r\n    }\r\n\r\n    // In the case of a 0ms delay, use an observable without auditTime\r\n    // since it does add a perceptible delay in processing overhead.\r\n    let observable = auditTimeInMs > 0 ?\r\n      this._scrolled.asObservable().auditTime(auditTimeInMs) :\r\n      this._scrolled.asObservable();\r\n\r\n    this._scrolledCount++;\r\n\r\n    if (!this._globalSubscription) {\r\n      this._globalSubscription = this._ngZone.runOutsideAngular(() => {\r\n        return Observable.merge(\r\n          Observable.fromEvent(window.document, 'scroll'),\r\n          Observable.fromEvent(window, 'resize')\r\n        ).subscribe(() => this._notify());\r\n      });\r\n    }\r\n\r\n    // Note that we need to do the subscribing from here, in order to be able to remove\r\n    // the global event listeners once there are no more subscriptions.\r\n    let subscription = observable.subscribe(callback);\r\n\r\n    subscription.add(() => {\r\n      this._scrolledCount--;\r\n\r\n      if (this._globalSubscription && !this.scrollableReferences.size && !this._scrolledCount) {\r\n        this._globalSubscription.unsubscribe();\r\n        this._globalSubscription = null;\r\n      }\r\n    });\r\n\r\n    return subscription;\r\n  }\r\n\r\n  /** Returns all registered Scrollables that contain the provided element. */\r\n  getScrollContainers(elementRef: ElementRef): Scrollable[] {\r\n    const scrollingContainers: Scrollable[] = [];\r\n\r\n    this.scrollableReferences.forEach((subscription: Subscription, scrollable: Scrollable) => {\r\n      if (this.scrollableContainsElement(scrollable, elementRef)) {\r\n        scrollingContainers.push(scrollable);\r\n      }\r\n    });\r\n\r\n    return scrollingContainers;\r\n  }\r\n\r\n  /** Returns true if the element is contained within the provided Scrollable. */\r\n  scrollableContainsElement(scrollable: Scrollable, elementRef: ElementRef): boolean {\r\n    let element = elementRef.nativeElement;\r\n    let scrollableElement = scrollable.getElementRef().nativeElement;\r\n\r\n    // Traverse through the element parents until we reach null, checking if any of the elements\r\n    // are the scrollable's element.\r\n    do {\r\n      if (element == scrollableElement) { return true; }\r\n    } while (element = element.parentElement);\r\n  }\r\n\r\n  /** Sends a notification that a scroll event has been fired. */\r\n  _notify() {\r\n    this._scrolled.next();\r\n  }\r\n}\r\n\r\nexport function SCROLL_DISPATCHER_PROVIDER_FACTORY(\r\n    parentDispatcher: ScrollDispatcher, ngZone: NgZone, platform: Platform) {\r\n  return parentDispatcher || new ScrollDispatcher(ngZone, platform);\r\n}\r\n\r\nexport const SCROLL_DISPATCHER_PROVIDER = {\r\n  // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\r\n  provide: ScrollDispatcher,\r\n  deps: [[new Optional(), new SkipSelf(), ScrollDispatcher], NgZone, Platform],\r\n  useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\r\n};\r\n"]}